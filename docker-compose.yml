services:
  web: # Our Flask web application
    build: # Build image from Dockerfile in./web directory
      context: ./website
    env_file:
      - ./.env #load the secret key
    container_name: smart_dashboard_web
    ports: # Map host port 5000 to container port 5000
      - "5000:5000"
      - "8089:8089" #For stress test
    volumes: #Mount code into container for live updates
      - ./website:/app
    networks: # Join a shared network so services can communicate
      - my-network
    depends_on: # Ensure web starts after database
      - db

  llm_service:
    build:
      context: ./llm_service
    container_name: llm_service
    ports:
      - "5001:5001"
    volumes:
      - ./llm_service:/app
    env_file:
      - ./.env # Load the GEMINI_API_KEY from the .env file
    networks: # <-- Add this
      - my-network # <-- Add this

  db: # MongoDB database service
      image: mongo:latest
      hostname: db
      container_name: db
      restart: unless-stopped
      command: ["--bind_ip_all"] # Allow connections from any IP
      ports: # default Mongo port
        - "27017:27017"
      volumes: # Persist database files on the host
        - ./data/db:/data/db
      networks:
        - my-network

  mongo-express:
    image: mongo-express
    container_name: mongo_express
    restart: unless-stopped
    ports:
      - "8081:8081"
    environment:
      ME_CONFIG_MONGODB_SERVER: db
      ME_CONFIG_BASICAUTH_USERNAME: admin
      ME_CONFIG_BASICAUTH_PASSWORD: pass
    networks:
      - my-network
    depends_on:
      - db

  test_runner:
    build:
      context: .
      dockerfile: Dockerfile.tests
    container_name: test_runner
    volumes:
      - .:/app
    networks:
      - my-network

    env_file:
      - ./.env

    depends_on:
      - web
      - db
      - llm_service


networks: # Define a custom network for service communication
  my-network:




    